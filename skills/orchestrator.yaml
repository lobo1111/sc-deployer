# Orchestrator Skill
# Manages parallel sub-agent execution and coordination

name: orchestrator
description: |
  Coordinates parallel execution of work orders across multiple sub-agents.
  Manages branch synchronization, handles dependencies, and ensures consistency.
  Acts as the central coordinator for the implementation phase.

trigger:
  type: routed
  from: work-order-planner
  input: execution_plan, work_orders, branches, sub_agent_assignments

context:
  required:
    - execution_plan
    - work_orders
    - branches
    - sub_agent_assignments
  runtime:
    - lane_status  # Track progress of each lane
    - phase_status  # Track progress of each phase
    - merge_queue  # Branches ready to merge

behavior:
  initialization:
    1_setup_tracking:
      create:
        - lane_status_map: {lane_id: pending}
        - work_order_status_map: {wo_id: pending}
        - phase_gates: {phase_id: blocked | open | complete}
      
    2_open_first_phase:
      action: mark_phase_open
      phase: 1
      notify: sub_agents_for_phase_1

  execution:
    parallel_dispatch:
      for_each: open_phase
      for_each: lane in phase
        dispatch:
          to: sub_agent_for_lane
          skill: implementer
          context:
            work_orders: lane.work_orders
            branch: lane.branch
            lane_id: lane.id
            phase_id: phase.id
          callback: on_lane_progress

    monitoring:
      on_lane_progress:
        events:
          work_order_started:
            action: update_status
            status: in_progress
          
          work_order_complete:
            action: update_status
            status: complete
            check: are_lane_dependencies_met
          
          lane_complete:
            action: handle_lane_completion
            steps:
              - mark_lane_complete
              - check_phase_completion
              - trigger_merge_if_ready
          
          lane_blocked:
            action: handle_blocking
            notify: coordinator
            reason: dependency_not_met | conflict | error
          
          lane_error:
            action: handle_error
            steps:
              - pause_dependent_lanes
              - notify_human
              - await_resolution

  synchronization:
    branch_merging:
      within_phase:
        # Lanes within same phase merge to integration branch
        trigger: all_lanes_in_phase_complete
        action: merge_lane_branches
        strategy:
          order: by_dependency  # Merge independent lanes first
          conflict_resolution:
            auto_resolvable: proceed
            manual_required: pause_and_notify_human
        
        steps:
          1_prepare_merge:
            - verify_all_lanes_complete
            - verify_all_tests_pass
            - check_for_conflicts
          
          2_merge_sequence:
            for_each: lane in topological_order
              - checkout: integration_branch
              - merge: lane.branch
              - run: validation_tests
              - on_conflict: pause_and_notify
          
          3_verify_integration:
            - run: unit_tests
            - run: integration_validation
            - verify: no_regressions
      
      phase_transition:
        trigger: phase_complete_and_merged
        action: open_next_phase
        steps:
          - mark_phase_complete
          - update_integration_branch
          - open_dependent_phase
          - dispatch_next_phase_lanes

    consistency_checks:
      between_lanes:
        # Ensure parallel work doesn't conflict
        checks:
          - no_overlapping_file_edits
          - output_names_unique
          - parameter_mappings_consistent
          - capability_docs_not_conflicting
        
        on_conflict_detected:
          action: pause_conflicting_lanes
          notify: human
          provide: conflict_details
      
      before_merge:
        checks:
          - all_work_orders_complete
          - all_tests_pass
          - capability_docs_updated
          - no_lint_errors

  dependency_management:
    cross_lane_dependencies:
      # When lane A produces output needed by lane B
      scenario: output_dependency
      handling:
        - lane_A completes work order that produces output
        - orchestrator captures output value
        - orchestrator provides output to lane_B
        - lane_B can proceed with dependent work order
    
    cross_phase_dependencies:
      # Phase 2 depends on Phase 1 completion
      handling:
        - phase_1 must fully complete and merge
        - integration branch updated with phase_1 changes
        - phase_2 lanes branch from updated integration
        - phase_2 sub-agents have access to phase_1 outputs

  progress_reporting:
    to_human:
      frequency: on_significant_events
      events:
        - phase_started
        - phase_complete
        - lane_blocked
        - conflict_detected
        - all_complete
      
      format: |
        ## Implementation Progress
        
        **Overall:** {percent_complete}%
        
        ### Phase {current_phase}: {phase_name}
        
        | Lane | Agent | Status | Progress | Current Task |
        |------|-------|--------|----------|--------------|
        {lane_status_table}
        
        ### Completed
        {completed_work_orders}
        
        ### Blocked/Issues
        {blocked_items}
        
        ### Next Steps
        {next_steps}

  completion:
    all_phases_complete:
      action: finalize_implementation
      steps:
        - verify_all_work_orders_complete
        - ensure_integration_branch_clean
        - run_full_test_suite
        - prepare_final_pr
      
      transition_to: pr-reviewer
      pass:
        - integration_branch
        - all_work_orders
        - test_results
        - implementation_summary

  error_handling:
    lane_failure:
      action: isolate_and_assess
      steps:
        - pause_lane
        - assess_impact_on_other_lanes
        - if independent: continue_other_lanes
        - if blocking: pause_dependent_lanes
        - notify_human_with_options:
            - retry_lane
            - skip_work_order
            - abort_implementation
    
    merge_conflict:
      action: pause_for_resolution
      steps:
        - identify_conflicting_changes
        - determine_if_auto_resolvable
        - if auto: apply_resolution_and_continue
        - if manual: notify_human_with_details
    
    timeout:
      threshold: configurable_per_work_order
      action: escalate
      notify: human

outputs:
  - implementation_complete: boolean
  - final_branch: integration branch name
  - all_work_orders: with final status
  - test_results: aggregated from all lanes
  - implementation_summary: what was done

transitions:
  - to: pr-reviewer
    when: all_phases_complete
    pass: final_branch, work_orders, test_results
  - to: human
    when: blocking_issue_requires_decision
  - to: self
    when: phases_remaining
