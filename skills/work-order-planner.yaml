# Work Order Planner Skill
# Creates detailed work orders with parallelization strategy

name: work-order-planner
description: |
  Breaks down a shaped requirement into concrete work orders (GitHub issues).
  Analyzes dependencies to determine what can be parallelized across sub-agents.
  Presents the plan to human for approval before creating issues.

trigger:
  type: routed
  from: requirement-shaper
  input: shaped_requirement

context:
  required:
    - shaped_requirement
    - product_catalog  # catalog.yaml
    - product_configs  # product.yaml files
    - current_capabilities  # CAPABILITY.md files
    - product_dependencies  # From catalog.yaml
  optional:
    - existing_issues  # Open GitHub issues
    - available_sub_agents  # Pool of sub-agents

behavior:
  planning:
    1_analyze_impact:
      for_each: affected_product
      determine:
        - template_changes_needed
        - parameter_changes_needed
        - output_changes_needed
        - dependency_changes_needed
        - capability_doc_updates
        - test_requirements
    
    2_create_work_orders:
      structure:
        - id: Unique identifier (WO-001, WO-002, etc.)
        - title: Clear, actionable title
        - product: Which product this affects
        - type: template | config | capability | test
        - description: What needs to be done
        - acceptance_criteria: How to verify completion
        - depends_on: Other work order IDs this depends on
        - blocks: Work order IDs that depend on this
        - estimated_complexity: small | medium | large
      
      standard_work_orders:
        - Template changes (per product)
        - CAPABILITY.md updates (per product)
        - Unit tests (per product)
        - Integration tests (if cross-product)
    
    3_analyze_dependencies:
      build_dependency_graph:
        - Map work order dependencies
        - Identify independent work orders (no dependencies)
        - Identify dependency chains
        - Calculate critical path
      
      dependency_rules:
        # Product-level dependencies from catalog.yaml
        - if product A depends on product B:
            then: work orders for B must complete before A
        
        # Work order type dependencies within same product
        - template_changes -> capability_updates -> tests
        
        # Cross-product dependencies
        - if work order changes outputs:
            then: dependent product work orders must wait
    
    4_plan_parallelization:
      strategy:
        # Group work orders into parallel lanes
        identify_parallel_lanes:
          - Independent products can be separate lanes
          - Same product work must be same lane (or carefully sequenced)
          - Tests can often run in parallel across products
        
        # Determine branching strategy
        branching:
          single_product_change:
            strategy: single_branch
            branch: "feature/{issue}-{slug}"
          
          multi_product_independent:
            strategy: parallel_branches
            branches:
              - "feature/{issue}-{product1}-{slug}"
              - "feature/{issue}-{product2}-{slug}"
            merge_to: "feature/{issue}-{slug}"  # Integration branch
          
          multi_product_dependent:
            strategy: sequential_on_single_branch
            branch: "feature/{issue}-{slug}"
            order: topological_sort_by_dependency
        
        # Assign to sub-agents
        sub_agent_assignment:
          rules:
            - One sub-agent per parallel lane
            - Sub-agent owns branch until lane complete
            - Coordinator monitors and manages merges
          
          assignment_criteria:
            - Balance load across available sub-agents
            - Keep related work orders together
            - Minimize context switching
    
    5_create_execution_plan:
      format:
        phases:
          - phase_id: 1
            name: "Foundation"
            parallel_lanes:
              - lane_id: A
                sub_agent: agent-1
                branch: "feature/123-networking-auth"
                work_orders: [WO-001, WO-002]
              - lane_id: B
                sub_agent: agent-2
                branch: "feature/123-database-auth"
                work_orders: [WO-003]
            sync_point: "All lane branches merged to integration branch"
          
          - phase_id: 2
            name: "Dependent Work"
            depends_on_phase: 1
            parallel_lanes:
              - lane_id: C
                sub_agent: agent-1
                branch: "feature/123-api-auth"
                work_orders: [WO-004, WO-005]
            sync_point: "Final PR to develop"
    
    6_present_plan:
      format: |
        I've drafted the following execution plan:
        
        ## Work Orders
        
        | ID | Title | Product | Depends On | Lane |
        |----|-------|---------|------------|------|
        {work_order_table}
        
        ## Execution Plan
        
        **Phase 1: {phase_1_name}** (parallel)
        {phase_1_lanes}
        
        **Phase 2: {phase_2_name}** (after Phase 1)
        {phase_2_lanes}
        
        ## Branching Strategy
        
        ```
        develop
          └── feature/{issue}-integration
                ├── feature/{issue}-{product1} (Lane A, Agent 1)
                ├── feature/{issue}-{product2} (Lane B, Agent 2)
                └── feature/{issue}-{product3} (Lane C, after merge)
        ```
        
        ## Sub-Agent Assignment
        
        | Agent | Lane | Work Orders | Branch |
        |-------|------|-------------|--------|
        {agent_assignment_table}
        
        **Estimated Timeline:**
        - Parallel phase: {parallel_estimate}
        - Sequential phase: {sequential_estimate}
        - Total: {total_estimate} (vs {sequential_only} if not parallelized)
        
        Do you approve this execution plan?
    
    7_wait_for_approval:
      accepted_responses:
        - "approved"
        - "looks good"
        - "proceed"
      on_modification_request:
        action: update_plan
        return_to: present_plan
      on_approval:
        action: create_issues_and_branches

  issue_creation:
    create_issues:
      for_each: work_order
      github_issue:
        title: "{type}: {title}"
        body: |
          ## Description
          {description}
          
          ## Product
          {product}
          
          ## Execution Context
          - **Lane:** {lane_id}
          - **Phase:** {phase_id}
          - **Assigned Agent:** {sub_agent}
          - **Branch:** {branch}
          
          ## Dependencies
          - **Depends on:** {depends_on}
          - **Blocks:** {blocks}
          
          ## Acceptance Criteria
          {acceptance_criteria}
        labels:
          - auto-generated
          - "{product}"
          - "{type}"
          - "lane-{lane_id}"
          - "phase-{phase_id}"
    
    create_branches:
      # Create integration branch
      - name: "feature/{issue}-integration"
        from: develop
      
      # Create lane branches
      for_each: lane
        - name: "{lane_branch}"
          from: "feature/{issue}-integration"

outputs:
  - work_orders: list of created GitHub issues with assignments
  - execution_plan: phases, lanes, and dependencies
  - branches: created branch structure
  - sub_agent_assignments: which agent handles which lane

transitions:
  - to: orchestrator
    when: plan_approved_and_created
    pass: execution_plan, work_orders, branches, sub_agent_assignments
  - to: self
    when: human_requests_changes
  - to: guide
    when: human_cancels
